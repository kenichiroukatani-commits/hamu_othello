<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>はむたくん、オセロで勝負だ！</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background: #f0f0f0;
            margin: 0;
        }

        .title {
            font-size: 2rem;
            font-weight: bold;
            text-align: center;
        }

        .subtitle {
            font-size: 1rem;
            color: #555;
            margin-bottom: 10px;
            text-align: center;
        }

        .controls {
            margin: 10px 0;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 5px;
        }

        .controls select,
        .controls button {
            padding: 5px 10px;
            font-size: 1rem;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 2px;
            width: 90vw;
            max-width: 500px;
            aspect-ratio: 1;
            margin-top: 10px;
        }

        .square {
            width: 100%;
            height: 100%;
            background: green;
            border: 1px solid #000;
            position: relative;
            cursor: pointer;
        }

        .disc {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            position: absolute;
            top: 10%;
            left: 10%;
        }

        .disc.black {
            background: black;
        }

        .disc.white {
            background: white;
        }

        .hint {
            background: lightgreen;
        }

        .scoreboard {
            margin-top: 10px;
            display: flex;
            gap: 15px;
            font-size: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .scoreboard span {
            font-weight: bold;
        }

        #status {
            margin-top: 10px;
            font-size: 1.2rem;
            font-weight: bold;
            text-align: center;
            word-break: break-word;
        }

        .square.cpu-move {
            box-shadow: 0 0 15px 5px yellow;
            transition: box-shadow 0.3s ease;
        }

        @media(max-width:400px) {
            .title {
                font-size: 1.5rem;
            }

            .subtitle {
                font-size: 0.9rem;
            }

            .controls select,
            .controls button {
                font-size: 0.9rem;
                padding: 4px 8px;
            }

            .scoreboard {
                font-size: 0.9rem;
            }
        }

        #kemutakun-container {
            position: relative;
            width: 80%;
            /* 移動範囲 */
            height: 20vw;
            /* 高さ */
            margin: 0 auto 10px;
            /* 上下マージン10px、左右中央 */
        }

        #kemutakun {
            position: absolute;
            top: 0;
            left: 50%;
            /* 左右中央の基準 */
            transform: translateX(-50%);
            /* 中央に寄せる */
            width: 20%;
            /* 画像サイズ調整 */
        }
    </style>
</head>

<body>

    <div class="title">はむたくん、オセロで勝負だ！</div>
    <div class="subtitle">CPU対戦のみ。対戦相手は「けむたくん」！</div>
    <!-- タイトル・サブタイトルの下にけむたくん画像を追加 -->


    <div id="kemutakun-container">
        <img src="kemutakun.png" id="kemutakun" alt="けむたくん">
    </div>

    <div class="controls">
        <select id="levelSelect">
            <option value="1">けむたくん Lv1（ランダム）</option>
            <option value="2">けむたくん Lv2（石数最大化）</option>
            <option value="3">けむたくん Lv3（角優先）</option>
            <option value="4">けむたくん Lv4</option>
            <option value="5">けむたくん Lv5</option>
            <option value="6">けむたくん Lv6（先読み1手）</option>
            <option value="7">けむたくん Lv7（先読み1手＋評価）</option>
            <option value="8">けむたくん Lv8（先読み2手）</option>
            <option value="9">けむたくん Lv9（先読み2手＋評価）</option>
            <option value="10">けむたくん Lv10（先読み3手＋安全手優先）</option>
        </select>
        <button id="btn-undo">Undo</button>
        <button id="btn-pass">Pass</button>
        <button id="btn-hint">Hint</button>
        <button id="btn-restart">Restart</button>
    </div>

    <div id="board" class="board"></div>

    <div class="scoreboard">
        <div>手番: <span id="turnText">黒</span></div>
        <div>黒 (はむたくん): <span id="blackScore">2</span></div>
        <div>白 (けむたくん): <span id="whiteScore">2</span></div>
    </div>

    <div id="status"></div>

    <script>
        const SIZE = 8, EMPTY = 0, BLACK = 1, WHITE = -1;
        const boardEl = document.getElementById('board');
        const turnText = document.getElementById('turnText');
        const blackScoreEl = document.getElementById('blackScore');
        const whiteScoreEl = document.getElementById('whiteScore');
        const statusEl = document.getElementById('status');
        const btnRestart = document.getElementById('btn-restart');
        const btnUndo = document.getElementById('btn-undo');
        const btnHint = document.getElementById('btn-hint');
        const btnPass = document.getElementById('btn-pass');
        const levelSelect = document.getElementById('levelSelect');

        let state = { board: createInitialBoard(), turn: BLACK, showHints: true, history: [], level: 1 };
        let lastCpuMove = null; // CPUの最後の手を記録
        function createInitialBoard() {
            const b = Array.from({ length: SIZE }, () => Array(SIZE).fill(EMPTY));
            const mid = SIZE / 2;
            b[mid - 1][mid - 1] = WHITE; b[mid][mid] = WHITE;
            b[mid - 1][mid] = BLACK; b[mid][mid - 1] = BLACK;
            return b;
        }

        const DIRS = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]];
        function inBounds(r, c) { return r >= 0 && r < SIZE && c >= 0 && c < SIZE; }
        function getLegalMoves(board, player) {
            const moves = new Map();
            for (let r = 0; r < SIZE; r++) for (let c = 0; c < SIZE; c++) {
                if (board[r][c] !== EMPTY) continue;
                const flipsAll = [];
                for (const [dr, dc] of DIRS) {
                    let i = r + dr, j = c + dc, st = [];
                    while (inBounds(i, j) && board[i][j] === -player) { st.push([i, j]); i += dr; j += dc; }
                    if (st.length > 0 && inBounds(i, j) && board[i][j] === player) flipsAll.push(...st);
                }
                if (flipsAll.length > 0) moves.set(`${r},${c}`, flipsAll);
            }
            return moves;
        }

        function applyMove(board, r, c, player, flips) {
            const next = board.map(row => row.slice());
            next[r][c] = player;
            for (const [i, j] of flips) next[i][j] = player;
            return next;
        }

        function score(board) {
            let black = 0, white = 0;
            for (const row of board) for (const v of row) { if (v === BLACK) black++; else if (v === WHITE) white++; }
            return { black, white };
        }

        function render() {
            boardEl.innerHTML = '';
            const legal = getLegalMoves(state.board, state.turn);
            for (let r = 0; r < SIZE; r++) for (let c = 0; c < SIZE; c++) {
                const sq = document.createElement('button');
                sq.className = 'square'; sq.dataset.r = r; sq.dataset.c = c;
                const v = state.board[r][c];
                if (v !== EMPTY) { const d = document.createElement('div'); d.className = 'disc ' + (v === BLACK ? 'black' : 'white'); sq.appendChild(d); }
                else if (legal.has(`${r},${c}`) && state.showHints) sq.classList.add('hint');
                sq.addEventListener('click', onPlace);
                boardEl.appendChild(sq);
            }
            const { black, white } = score(state.board);
            blackScoreEl.textContent = black; whiteScoreEl.textContent = white;
            turnText.textContent = state.turn === BLACK ? '黒' : '白';
            checkGameOver();
        }

        function onPlace(e) {
            const r = +e.currentTarget.dataset.r;
            const c = +e.currentTarget.dataset.c;
            makeMove(r, c);
        }

        function makeMove(r, c) {
            const legal = getLegalMoves(state.board, state.turn);
            const key = `${r},${c}`;
            if (!legal.has(key)) return;
            pushHistory();
            state.board = applyMove(state.board, r, c, state.turn, legal.get(key));
            state.turn *= -1;
            render();
            if (state.turn === WHITE) {
                const legalWhite = getLegalMoves(state.board, WHITE);
                if (legalWhite.size === 0) { state.turn = BLACK; render(); return; }
                const move = chooseMove(legalWhite, state.level, state.board, WHITE);
                if (move) {
                    lastCpuMove = move; // CPUの手を記録
                    const delay = 1000 + Math.random() * 1000; // 1〜2秒ランダムで人間っぽく
                    setTimeout(() => {
                        makeMove(move[0], move[1]);
                        highlightMove(lastCpuMove[0], lastCpuMove[1]); // 光らせる
                    }, delay);
                }
            }

        }



        function cpuMove() {
            const legal = getLegalMoves(state.board, WHITE);
            if (legal.size === 0) { state.turn = BLACK; render(); return; }
            const move = chooseMove(legal, state.level, state.board, WHITE);
            if (move) makeMove(move[0], move[1]);
        }

        function chooseMove(legal, level, board, player) {
            const moves = [...legal.keys()].map(k => k.split(',').map(Number));
            if (level === 1) return moves[Math.floor(Math.random() * moves.length)];
            let bestVal = -Infinity, bestMove = null;
            const depth = level >= 10 ? 3 : level >= 8 ? 2 : level >= 6 ? 1 : 0;
            for (const [r, c] of moves) {
                const flips = legal.get(`${r},${c}`);
                let val = minimax(applyMove(board, r, c, player, flips), depth, -player, level);
                if (val > bestVal) { bestVal = val; bestMove = [r, c]; }
            }
            return bestMove;
        }

        function minimax(board, depth, player, level) {
            if (depth === 0) return evaluateBoard(board, player, level);
            const legal = getLegalMoves(board, player);
            if (legal.size === 0) return evaluateBoard(board, player, level);
            let best = (player === WHITE) ? -Infinity : Infinity;
            for (const key of legal.keys()) {
                const [r, c] = key.split(',').map(Number);
                const flips = legal.get(key);
                const newBoard = applyMove(board, r, c, player, flips);
                const val = minimax(newBoard, depth - 1, -player, level);
                if (player === WHITE) { if (val > best) best = val; }
                else { if (val < best) best = val; }
            }
            return best;
        }

        function evaluateBoard(board, player, level) {
            let val = 0;
            for (let r = 0; r < SIZE; r++) for (let c = 0; c < SIZE; c++) {
                if (board[r][c] === WHITE) val += 1;
                if (board[r][c] === BLACK) val -= 1;
            }
            const corners = [[0, 0], [0, 7], [7, 0], [7, 7]];
            for (const [r, c] of corners) { if (board[r][c] === WHITE) val += 10; if (board[r][c] === BLACK) val -= 10; }
            for (let i = 0; i < SIZE; i++) { if (board[0][i] === WHITE || board[7][i] === WHITE) val += 3; if (board[0][i] === BLACK || board[7][i] === BLACK) val -= 3; }
            for (let i = 1; i < SIZE - 1; i++) { if (board[i][0] === WHITE || board[i][7] === WHITE) val += 3; if (board[i][0] === BLACK || board[i][7] === BLACK) val -= 3; }
            return val;
        }

        function pushHistory() { state.history.push({ board: state.board.map(r => r.slice()), turn: state.turn }); }
        function undo() { const prev = state.history.pop(); if (prev) { state.board = prev.board; state.turn = prev.turn; render(); } }
        function restart() { state.board = createInitialBoard(); state.turn = BLACK; state.history = []; statusEl.textContent = ''; render(); }
        function toggleHint() { state.showHints = !state.showHints; render(); }

        function checkGameOver() {
            const legalBlack = getLegalMoves(state.board, BLACK);
            const legalWhite = getLegalMoves(state.board, WHITE);
            if (legalBlack.size === 0 && legalWhite.size === 0) {
                const { black, white } = score(state.board);
                if (black > white) statusEl.textContent = '勝者: はむたくん (黒)！';
                else if (white > black) statusEl.textContent = '勝者: けむたくん (白)！';
                else statusEl.textContent = '引き分けです！';
            }
        }

        btnRestart.addEventListener('click', restart);
        btnUndo.addEventListener('click', undo);
        btnHint.addEventListener('click', toggleHint);
        btnPass.addEventListener('click', () => { state.turn *= -1; render(); });
        levelSelect.addEventListener('change', () => { state.level = +levelSelect.value; });

        render();
        function highlightMove(r, c) {
            const squares = document.querySelectorAll('.square');
            const sq = Array.from(squares).find(s => +s.dataset.r === r && +s.dataset.c === c);
            if (!sq) return;
            sq.classList.add('cpu-move');
            setTimeout(() => sq.classList.remove('cpu-move'), 1000); // 1秒後に消える
        }

        const kemutakunEl = document.getElementById('kemutakun');
        let kemuOffset = 0;        // 中央からの相対オフセット
        let kemuDir = 1;           // 1=右, -1=左
        const kemuSpeed = 10;      // px単位の移動量
        const kemuMax = 50;        // 中央から左右最大50px

        setInterval(() => {
            kemuOffset += kemuSpeed * kemuDir;
            if (kemuOffset > kemuMax || kemuOffset < -kemuMax) kemuDir *= -1;
            kemutakunEl.style.transform = `translateX(-50%) translateX(${kemuOffset}px)`;
        }, 200);
    </script>

</body>

</html>